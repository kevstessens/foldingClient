'use strict';

var CSSParseError = require('./error');
var TokenType = require('./const');
var tokenize = require('./tokenize');

var source;
var tokens;
var needInfo;
var pos;
var currentBlockLN;
var endPosStack = [];
var endPos;

var NodeType = {
    Atkeyword: 'atkeyword',
    Atruleb: 'atruleb',
    Atruler: 'atruler',
    Atrulerq: 'atrulerq',
    Atrulers: 'atrulers',
    Atrules: 'atrules',
    Attrib: 'attrib',
    Attrselector: 'attrselector',
    Block: 'block',
    Braces: 'braces',
    Clazz: 'clazz',
    Combinator: 'combinator',
    Comment: 'comment',
    Declaration: 'declaration',
    DeclDelim: 'decldelim',
    Delim: 'delim',
    Dimension: 'dimension',
    Filter: 'filter',
    Filterv: 'filterv',
    FunctionBody: 'functionBody',
    FunctionExpression: 'functionExpression',
    Funktion: 'funktion',
    Ident: 'ident',
    Important: 'important',
    Namespace: 'namespace',
    Nth: 'nth',
    Nthselector: 'nthselector',
    Number: 'number',
    Operator: 'operator',
    Percentage: 'percentage',
    Progid: 'progid',
    Property: 'property',
    Pseudoc: 'pseudoc',
    Pseudoe: 'pseudoe',
    Raw: 'raw',
    Ruleset: 'ruleset',
    Selector: 'selector',
    Shash: 'shash',
    Simpleselector: 'simpleselector',
    Spaces: 's',
    String: 'string',
    Stylesheet: 'stylesheet',
    Unary: 'unary',
    Unknown: 'unknown',
    Uri: 'uri',
    Value: 'value',
    Vhash: 'vhash'
};

function fail(msg) {
    var token = tokens[pos];
    var line;
    var column;
//    throw new Error;

    if (!token) {
        token = tokens[tokens.length - 1];
        var lines = token.value.split(/\r*\n\r*/);
        line = token.line + lines.length - 1;
        column = lines.length === 1 ? token.column + token.value.length : lines.pop().length + 1;
    } else {
        line = token.line;
        column = token.column;
    }

    throw new CSSParseError(msg || 'CSS parse error', source, line, column);
}

function createNode(type, pos, args) {
    var result;

    if (needInfo) {
        var token = tokens[pos];
        result = [{
            offset: token.offset,
            line: token.line,
            column: token.column
        }, type];
    } else {
        result = [type];
    }

    if (args) {
        return result.concat(args);
    }

    return result;
}

function Spaces() {
    var buffer = [];
    var token;

    while (token = pick()) {
        if (token.type !== TokenType.Space &&
            token.type !== TokenType.Newline &&
            token.type !== TokenType.Tab) {
            break;
        }

        buffer.push(readToken().value);
    }

    if (buffer.length) {
        return [
            buffer.join('')
        ];
    }
}


function Comment() {
    var token = readToken();

    if (token.type === TokenType.CommentML) {
        return [
            token.value.substring(2, token.value.length - 2)
        ];
    }
}

function SpacesOrComment() {
    return Spaces() || Comment();
}

function isLeftCurlyBracket_() {
    return pick().type === TokenType.LeftCurlyBracket;
}

function getUnary() {
    if (pick().type === TokenType.PlusSign ||
        pick().type === TokenType.HyphenMinus) {
        return [
            readToken().value
        ];
    }
}

function getString() {
    if (pick().type === TokenType.StringSQ ||
        pick().type === TokenType.StringDQ) {
        return [
            readToken().value
        ];
    }
}

function getHash() {
    if (readToken().type === TokenType.NumberSign &&
        (pick().type === TokenType.Identifier || pick().type === TokenType.DecimalNumber)) {
        return [
            readToken().value
        ];
    }
}

function getDecimalNumber() {
    var token = readToken();
    var value = token.value;

    switch (token.type) {
        case TokenType.DecimalNumber:
            if (pick().type === TokenType.FullStop) {
                value += readToken().value;
            } else {
                break;
            }

        case TokenType.FullStop:
            if (pick().type === TokenType.DecimalNumber) {
                value += readToken().value;
            } else {
                fail();
            }
            break;


        default:
            return;
    }

    return [
        value
    ];
}

function getCombinator() {
    if (pick().type === TokenType.PlusSign ||
        pick().type === TokenType.GreaterThanSign ||
        pick().type === TokenType.Tilde ||
        pick().type === TokenType.Space) {
        return [
            readToken().value
        ];
    }
}

function getPseudoSelector() {

}

function getSimpleSelector() {
    var buffer = [];
    var stop = false;
    var node;

    while (pos < endPos) {
        // type and universal selectors could be used only in beginning
        if (!node) {
            node =
                TypeSelector() ||
                UniversalSelector();
        }

        if (!node) {
            node =
                HashSelector() ||
                ClassNameSelector() //||
                //AttributeSelector() ||
                //Negation() ||
                //PseudoSelector() ||
                // pseudo-elements are restricted to one per selector and
                // occur only in the last simple selector sequence
                // TODO: add checks
                //PseudoElementSelector();
        }

        if (node) {
            buffer.push(node);
        } else {
            break;
        }
    }

    if (buffer.length) {
        return buffer;
    }
}

function getProperty_() {
    var buffer = [];
    var ident = Identifier();
    var node;

    if (!ident) {
        return;
    }

    while (node = SpacesOrComment()) {
        buffer.push(node);
    }

    if (pick().type === TokenType.Colon) {
        readToken();
    } else {
        fail('Colon expected');
    }

    return [ident].concat(buffer);
}

function getValue_() {
    var buffer = [];
    var node;

    while (pos < endPos) {
        node =
            Spaces() ||
            Comment() ||
            Identifier() ||
            DecimalNumber();

        if (node) {
            buffer.push(node);
        } else {
            if (pick().type === TokenType.Semicolon) {
                break;
            }

            buffer.push(['skiped', readToken().type]);
        }
    }

    if (buffer.length) {
        return buffer;
    }
}

function getStylesheet() {
    var stylesheet = [];

    while (pos < tokens.length) {
        var node =
            Spaces() ||
            Comment() ||
            Ruleset();

        if (node) {
            stylesheet.push(node);
        } else {
            fail();
        }
    }

    return stylesheet;
}

var Spaces = createNodeType(NodeType.Spaces, Spaces);
var Comment = createNodeType(NodeType.Comment, Comment);
var Delim = createNodeType(NodeType.Delim, empty(TokenType.Comma));
var DeclDelim = createNodeType(NodeType.DeclDelim, empty(TokenType.Semicolon));
var StringNode = createNodeType(NodeType.String, getString);
var Unary = createNodeType(NodeType.Unary, getUnary);
var NamespacePrefix = createNodeType('-')
var Identifier = createNodeType(NodeType.Ident, atom(TokenType.Identifier));
var Vhash = createNodeType(NodeType.Vhash, getHash);
//var SimpleSelector = createNodeType(NodeType.Simpleselector, getSimpleSelector_);

var TypeSelector = createNodeType(NodeType.Identifier, Function);
var UniversalSelector = createNodeType(NodeType.Identifier, Function);
var ClassNameSelector = createNodeType(NodeType.Clazz, prefix(TokenType.FullStop, Identifier));
var HashSelector = createNodeType(NodeType.Shash, getHash);
var AttributeSelector = createNodeType(NodeType.Attrselector, Function);
var PseudoSelector = createNodeType(NodeType.Pseudoe, getPseudoSelector);
var Negation = createNodeType(NodeType.Funktion, Function);

var SimpleSelector = createNodeType(null, getSimpleSelector);
var Combinator = createNodeType(NodeType.Combinator, getCombinator);
var Selector = createNodeType(NodeType.Simpleselector, list(
    SimpleSelector,
    Combinator,
    isLeftCurlyBracket_
));

var SelectorGroup = createNodeType(NodeType.Selector, list(
    Selector,
    Delim,
    isLeftCurlyBracket_
));
var Property = createNodeType(NodeType.Property, getProperty_);
var DecimalNumber = createNodeType(NodeType.Number, getDecimalNumber);
var Dimension = createNodeType(NodeType.Dimension, compose(
    DecimalNumber,
    Identifier
));
var Value = createNodeType(NodeType.Value, setOf(any(
    SpacesOrComment,
    Identifier,
    StringNode,
    Unary,
    Dimension,
    DecimalNumber,
    Vhash
), function() {
    if (!pick()) return;
    return pick().type === TokenType.LeftCurlyBracket ||
           pick().type === TokenType.Comma;
}));
var Declaration = createNodeType(NodeType.Declaration, compose(
    Property,
    Value
));
var Block = createNodeType(NodeType.Block, braces(
    TokenType.LeftCurlyBracket,
    TokenType.RightCurlyBracket,
    setOf(any(
        SpacesOrComment,
        Declaration,
        DeclDelim
    ))
));
var Ruleset = createNodeType(NodeType.Ruleset, compose(
    Selector,
    Block
));

var Stylesheet = createNodeType(NodeType.Stylesheet, getStylesheet);



///////

function skip(n) {
    pos += n || 1;
}

function pick() {
    return tokens[pos];
}

function readToken() {
    if (pos === endPos) {
        throw new Error();
        fail(endPosStack.length
            ? 'Unexpected end of block'
            : 'Unexpected end of file'
        );
    }

    return tokens[pos++] || {};
}

function createNodeType(type, fn) {
    var nodeType = function(required) {
        var storedPos = pos;
        var args = fn(required);

        if (!args) {
            if (required) {
                fail();
            }
            pos = storedPos;
        } else {
            return createNode(type, storedPos, args);
        }
    };

    return nodeType;
}

function empty(tokenType) {
    return function() {
        if (readToken().type === tokenType) {
            return [];
        }
    };
}

function atom(tokenType) {
    return function() {
        var token = readToken();

        if (token.type === tokenType) {
            return [
                token.value
            ];
        }
    };
}

function prefix(tokenType, reader) {
    return function() {
        var token = readToken();

        if (token.type === tokenType) {
            var node = reader();

            if (node) {
                return [
                    node
                ];
            }
        }
    };
}


function braces(start, end, reader) {
    return function() {
        var token = readToken();

        // should starts with `start` token type
        if (token.type !== start) {
            fail(start + ' expected'); // ?
        }

        endPosStack.push(endPos);
        endPos = token.right;

        var content = reader();

        if (!content) {
            fail('xx');
        }

        // everything inside braces should be readden
        if (pos !== token.right) {
            return;
        }

        endPos = endPosStack.pop();
        skip();

        return content;
    };
}

function any(readers) {
    var readers = Array.prototype.slice.call(arguments);

    return function() {
        for (var i = 0; i < readers.length; i++) {
            var node = readers[i]();

            if (node) {
                return node;
            }
        }

        fail();
    };
}

function setOf(reader, stop) {
    return function() {
        var buffer = [];
        var node;

        while (pos < endPos) {
            node = reader();

            if (node) {
                buffer.push(node);
            } else {
                fail();
            }

            if (stop && stop()) {
                break;
            }
        }


        if (buffer.length) {
            return buffer;
        }
    };
}

function list(entity, delimeter, correctStop) {
    return function() {
        var reader = entity;
        var buffer = [];
        var node;

        while (pos < endPos) {
            node = reader();

            if (node) {
                buffer.push(node);
            } else {
                if (reader === delimeter) {
                    break;
                }

                return;
            }

            reader = reader === entity ? (delimeter || entity) : entity;
        }

        if (correctStop && !correctStop()) {
            return;
        }

        if (buffer.length) {
            return buffer;
        }
    };
}

function compose() {
    var readers = Array.prototype.slice.call(arguments);

    return function() {
        var buffer = [];
        var node;

        while (node = SpacesOrComment()) {
            buffer.push(node);
        }

        for (var i = 0; i < readers.length; i++) {
            node = readers[i]();

            if (!node) {
                return;
            }

            buffer.push(node);
        }

        if (buffer.length) {
            return buffer;
        }
    };
}

var CSSPRules = {
    'atkeyword': function() { if (checkAtkeyword(pos)) return getAtkeyword() },
    'atruleb': function() { if (checkAtruleb(pos)) return getAtruleb() },
    'atruler': function() { if (checkAtruler(pos)) return getAtruler() },
    'atrulerq': function() { if (checkAtrulerq(pos)) return getAtrulerq() },
    'atrulers': function() { if (checkAtrulers(pos)) return getAtrulers() },
    'atrules': function() { if (checkAtrules(pos)) return getAtrules() },
    'attrib': function() { if (checkAttrib(pos)) return getAttrib() },
    'attrselector': AttributeSelector,
    'block': Block,
    'braces': function() { if (checkBraces(pos)) return getBraces() },
    'clazz': ClassNameSelector,
    'combinator': function() { if (checkCombinator(pos)) return getCombinator() },
    'comment': Comment,
    'declaration': Declaration,
    'decldelim': DeclDelim,
    'delim': Delim,
    'dimension': Dimension,
    'filter': function() { if (checkFilter(pos)) return getFilter() },
    'filterv': function() { if (checkFilterv(pos)) return getFilterv() },
    'functionExpression': function() { if (checkFunctionExpression(pos)) return getFunctionExpression() },
    'funktion': function() { if (checkFunktion(pos)) return getFunktion() },
    'ident': Identifier,
    'important': function() { if (checkImportant(pos)) return getImportant() },
    'namespace': function() { if (checkNamespace(pos)) return getNamespace() },
    'nth': function() { if (checkNth(pos)) return getNth() },
    'nthselector': function() { if (checkNthselector(pos)) return getNthselector() },
    'number': DecimalNumber,
    'operator': function() { if (checkOperator(pos)) return getOperator() },
    'percentage': function() { if (checkPercentage(pos)) return getPercentage() },
    'progid': function() { if (checkProgid(pos)) return getProgid() },
    'property': Property,
    'pseudoc': function(){},
    'pseudoe': PseudoSelector,
    'ruleset': Ruleset,
    's': Spaces,
    'selector': Selector,
    'shash': HashSelector,
    'simpleselector': SimpleSelector,
    'string': StringNode,
    'stylesheet': Stylesheet,
    'unary': Unary,
    'unknown': function() { if (checkUnknown(pos)) return getUnknown() },
    'uri': function() { if (checkUri(pos)) return getUri() },
    'value': Value,
    'vhash': Vhash
};


module.exports = function parse(_source, rule, _needInfo) {
    rule = rule || 'stylesheet';
    needInfo = _needInfo;
    pos = 0;

    //markSC();

    if (1) {
        source = 'a  b + c{}';
        tokens = tokenize(source);
        endPos = tokens.length;
        endPosStack = [];
        console.log(tokens);

        var ast = CSSPRules[rule]();

        source = null;
        tokens = null;

        return ast;
    }

    source = _source;
    tokens = tokenize(source);
    endPos = tokens.length;
    endPosStack = [];

    var ast = CSSPRules[rule]();

    source = null;
    tokens = null;

    return ast;
};
